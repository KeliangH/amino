<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>amino: lapack_doc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>lapack_doc.c File Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#ad81e1d79d969b6d3448b52d83426f8ed">dgetri_</a> (const int *N, double *A, const int *LDA, const int *IPIV, double *WORK, const int *LWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type for operations  <a href="#ad81e1d79d969b6d3448b52d83426f8ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a7e7dbf9e241b4bfaab9c534cba4418fb">dgetrf_</a> (const int *M, const int *N, double *A, const int *LDA, int *IPIV, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <a href="#a7e7dbf9e241b4bfaab9c534cba4418fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a00fb7fb5cfb28095fe4fff98414b9535">dgesvd_</a> (const char jobu[1], const char jobvt[1], const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *Vt, const int *ldvt, double *work, const int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute SVD.  <a href="#a00fb7fb5cfb28095fe4fff98414b9535"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#accd9d170d878a61ef4f5591665f87cc0">dgelsd_</a> (const int *M, const int *N, const int *NRHS, double *A, const int *LDA, double *B, const int *LDB, double *S, const double *RCOND, int *RANK, double *WORK, int *LWORK, int *IWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DGELSD computes the minimum-norm solution to a real linear least squares problem.  <a href="#accd9d170d878a61ef4f5591665f87cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a81d755e4d14aa702d98cea3b494cc8db">dgebal_</a> (const char JOB[1], int *N, double *A, const int *LDA, int *ILO, int *IHI, double *SCALE, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balances a general real matrix A.  <a href="#a81d755e4d14aa702d98cea3b494cc8db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a5dc85bb5d633dcb7d106c685b01d7bda">dgees_</a> (const char JOBVS[1], const char SORT[1], int(*SELECT)(const double *, const double *), const int *N, double *A, const int *LDA, int *SDIM, double *WR, double *WI, double *VS, const int *LDVS, double *WORK, const int *LWORK, int *BWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z.  <a href="#a5dc85bb5d633dcb7d106c685b01d7bda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a655036816493eebaf9202e0cfa782385">dgels_</a> (const char TRANS[1], const int *M, const int *N, const int *NRHS, double *A, const int *LDA, double *B, const int *LDB, double *WORK, const int *LWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A.  <a href="#a655036816493eebaf9202e0cfa782385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a67e9b8a55c0c3e696be317066d3ce573">dlacpy_</a> (const char UPLO[1], const int *M, const int *N, const double *A, const int *LDA, double *B, const int *LDB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all or part of a two-dimensional matrix A to another matrix B.  <a href="#a67e9b8a55c0c3e696be317066d3ce573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568e06fcc6bbf6cbe4f484d172a2b9ad"></a><!-- doxytag: member="lapack_doc.c::dlapy2_" ref="a568e06fcc6bbf6cbe4f484d172a2b9ad" args="(const double *x, const double *y)" -->
AA_API double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a568e06fcc6bbf6cbe4f484d172a2b9ad">dlapy2_</a> (const double *x, const double *y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sqrt(x**2+y**2), taking care not to cause unnecessary overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dd42232fc7f212d747f0ad7d7baa5be"></a><!-- doxytag: member="lapack_doc.c::dlapy3_" ref="a1dd42232fc7f212d747f0ad7d7baa5be" args="(const double *x, const double *y, const double *z)" -->
AA_API double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a1dd42232fc7f212d747f0ad7d7baa5be">dlapy3_</a> (const double *x, const double *y, const double *z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sqrt(x**2+y**2+z**2), taking care not to cause unnecessary overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#afa186c0bc0ceae470beb34001467357d">dlaruv_</a> (int ISEED[4], const int *N, double *X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of n random real numbers from a uniform (0,1) distribution (n &lt;= 128).  <a href="#afa186c0bc0ceae470beb34001467357d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#ae4174555ba70641cea33e3cb92048e84">dlarnv_</a> (const int *IDIST, int ISEED[4], const int *N, double *X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of n random real numbers from a uniform or normal distribution.  <a href="#ae4174555ba70641cea33e3cb92048e84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a60ae7d4abe435240135b72ab9f6255e4">dlascl_</a> (const char TYPE[1], const int *KL, const int *KU, const double *CFROM, const double *CTO, const int *M, const int *N, double *A, const int *LDA, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies the M by N real matrix A by the real scalar CTO/CFROM.  <a href="#a60ae7d4abe435240135b72ab9f6255e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a229bde086d03f7a2cdd23d9701e12e38">dlaset_</a> (const char UPLO[1], const int *M, const int *N, const double *ALPHA, const double *BETA, double *A, const int *LDA)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initializes an m-by-n matrix A to BETA on the diagonal and ALPHA on the offdiagonals.  <a href="#a229bde086d03f7a2cdd23d9701e12e38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a971eb1a938d6f3441cacd0439951d477">dlag2s_</a> (const int *M, const int *N, double *A, const int *LDA, float *SA, const int *LDSA, const int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a DOUBLE PRECISION matrix, SA, to a SINGLE PRECISION matrix, A.  <a href="#a971eb1a938d6f3441cacd0439951d477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#ab44a6964fe2f0b269fb113fed2208931">slag2d_</a> (const int *M, const int *N, float *SA, const int *LDSA, double *A, const int *LDA, const int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a SINGLE PRECISION matrix, SA, to a DOUBLE PRECISION matrix, A.  <a href="#ab44a6964fe2f0b269fb113fed2208931"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a241a9b27a306dc51b21fbf08cf59b3c1">sgetri_</a> (const int *N, float *A, const int *LDA, const int *IPIV, float *WORK, const int *LWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type for operations  <a href="#a241a9b27a306dc51b21fbf08cf59b3c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a60936fca8832219b2caa0d66593e31e0">sgetrf_</a> (const int *M, const int *N, float *A, const int *LDA, int *IPIV, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <a href="#a60936fca8832219b2caa0d66593e31e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a4005be2875da71d06ac3523dd2d2ab9d">sgesvd_</a> (const char jobu[1], const char jobvt[1], const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *Vt, const int *ldvt, float *work, const int *lwork, int *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute SVD.  <a href="#a4005be2875da71d06ac3523dd2d2ab9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#adf87acce17938a93459011156ad0b17f">sgelsd_</a> (const int *M, const int *N, const int *NRHS, float *A, const int *LDA, float *B, const int *LDB, float *S, const float *RCOND, int *RANK, float *WORK, int *LWORK, int *IWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DGELSD computes the minimum-norm solution to a real linear least squares problem.  <a href="#adf87acce17938a93459011156ad0b17f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a4136300dce44d53bf39d86bfe123cf38">sgebal_</a> (const char JOB[1], int *N, float *A, const int *LDA, int *ILO, int *IHI, float *SCALE, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balances a general real matrix A.  <a href="#a4136300dce44d53bf39d86bfe123cf38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a26f3ec0151ace5d61b70bfe87f6017ad">sgees_</a> (const char JOBVS[1], const char SORT[1], int(*SELECT)(const float *, const float *), const int *N, float *A, const int *LDA, int *SDIM, float *WR, float *WI, float *VS, const int *LDVS, float *WORK, const int *LWORK, int *BWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z.  <a href="#a26f3ec0151ace5d61b70bfe87f6017ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a24f702b20a2c65d0b7b1b95bda7fb984">sgels_</a> (const char TRANS[1], const int *M, const int *N, const int *NRHS, float *A, const int *LDA, float *B, const int *LDB, float *WORK, const int *LWORK, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A.  <a href="#a24f702b20a2c65d0b7b1b95bda7fb984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#acc10696c60ae03d1f4c083aad8235085">slacpy_</a> (const char UPLO[1], const int *M, const int *N, const float *A, const int *LDA, float *B, const int *LDB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all or part of a two-dimensional matrix A to another matrix B.  <a href="#acc10696c60ae03d1f4c083aad8235085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97185d7e6bd63381a4705a1cbf30a453"></a><!-- doxytag: member="lapack_doc.c::slapy2_" ref="a97185d7e6bd63381a4705a1cbf30a453" args="(const float *x, const float *y)" -->
AA_API float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a97185d7e6bd63381a4705a1cbf30a453">slapy2_</a> (const float *x, const float *y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sqrt(x**2+y**2), taking care not to cause unnecessary overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff3fcf4e05a8f3089f661c96b7f0baed"></a><!-- doxytag: member="lapack_doc.c::slapy3_" ref="aff3fcf4e05a8f3089f661c96b7f0baed" args="(const float *x, const float *y, const float *z)" -->
AA_API float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#aff3fcf4e05a8f3089f661c96b7f0baed">slapy3_</a> (const float *x, const float *y, const float *z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sqrt(x**2+y**2+z**2), taking care not to cause unnecessary overflow. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a96a60f4f8ac54fb62bec4fc2c90a5795">slaruv_</a> (int ISEED[4], const int *N, float *X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of n random real numbers from a uniform (0,1) distribution (n &lt;= 128).  <a href="#a96a60f4f8ac54fb62bec4fc2c90a5795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a25b2a8d91520fea3b9e5f081441f422b">slarnv_</a> (const int *IDIST, int ISEED[4], const int *N, float *X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of n random real numbers from a uniform or normal distribution.  <a href="#a25b2a8d91520fea3b9e5f081441f422b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a49394e995df80d92c0429d530553df56">slascl_</a> (const char TYPE[1], const int *KL, const int *KU, const float *CFROM, const float *CTO, const int *M, const int *N, float *A, const int *LDA, int *INFO)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies the M by N real matrix A by the real scalar CTO/CFROM.  <a href="#a49394e995df80d92c0429d530553df56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a1d44fc39f4579d8dea5f4b8fb334f485">slaset_</a> (const char UPLO[1], const int *M, const int *N, const float *ALPHA, const float *BETA, float *A, const int *LDA)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initializes an m-by-n matrix A to BETA on the diagonal and ALPHA on the offdiagonals.  <a href="#a1d44fc39f4579d8dea5f4b8fb334f485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AA_API int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lapack__doc_8c.html#a049f2c28303ee20ec58495b75003a61a">ilaenv_</a> (const int *ispec, const char *name, const char *opts, const int *n1, const int *n2, const int *n3, const int *n4, int name_length, int opts_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ILAENV is called from the LAPACK routines to choose problem-dependent parameters for the local environment.  <a href="#a049f2c28303ee20ec58495b75003a61a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a81d755e4d14aa702d98cea3b494cc8db"></a><!-- doxytag: member="lapack_doc.c::dgebal_" ref="a81d755e4d14aa702d98cea3b494cc8db" args="(const char JOB[1], int *N, double *A, const int *LDA, int *ILO, int *IHI, double *SCALE, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgebal_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>JOB</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Balances a general real matrix A. </p>
<p>This involves, first, permuting A by a similarity transformation to isolate eigenvalues in the first 1 to ILO-1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional.</p>
<p>Balancing may reduce the 1-norm of the matrix, and improve the accuracy of the computed eigenvalues and/or eigenvectors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>JOB</em>&nbsp;</td><td>Specifies the operations to be performed on A:</p>
<ul>
<li>= 'N': none: simply set ILO = 1, IHI = N, SCALE(I) = 1.0 for i = 1,...,N;</li>
<li>= 'P': permute only;</li>
<li>= 'S': scale only;</li>
<li>= 'B': both permute and scale.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the input matrix A. On exit, A is overwritten by the balanced matrix. If JOB = 'N', A is not referenced. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ILO</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IHI</em>&nbsp;</td><td>ILO and IHI are set to integers such that on exit A(i,j) = 0 if i &gt; j and j = 1,...,ILO-1 or I = IHI+1,...,N. If JOB = 'N' or 'S', ILO = 1 and IHI = N.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SCALE</em>&nbsp;</td><td>dimension (N) Details of the permutations and scaling factors applied to A. If P(j) is the index of the row and column interchanged with row and column j and D(j) is the scaling factor applied to row and column j, then SCALE(j) = P(j) for j = 1,...,ILO-1 = D(j) for j = ILO,...,IHI = P(j) for j = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dc85bb5d633dcb7d106c685b01d7bda"></a><!-- doxytag: member="lapack_doc.c::dgees_" ref="a5dc85bb5d633dcb7d106c685b01d7bda" args="(const char JOBVS[1], const char SORT[1], int(*SELECT)(const double *, const double *), const int *N, double *A, const int *LDA, int *SDIM, double *WR, double *WI, double *VS, const int *LDVS, double *WORK, const int *LWORK, int *BWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgees_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>JOBVS</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>SORT</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const double *, const double *)&nbsp;</td>
          <td class="paramname"> <em>SELECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>SDIM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. </p>
<p>This gives the Schur factorization A = Z*T*(Z**T).</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left. The leading columns of Z then form an orthonormal basis for the invariant subspace corresponding to the selected eigenvalues.</p>
<p>A matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ]</p>
<p>where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>JOBVS</em>&nbsp;</td><td><ul>
<li>= 'N': Schur vectors are not computed;</li>
<li>= 'V': Schur vectors are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SORT</em>&nbsp;</td><td>Specifies whether or not to order the eigenvalues on the diagonal of the Schur form.</p>
<ul>
<li>= 'N': Eigenvalues are not ordered;</li>
<li>= 'S': Eigenvalues are ordered (see SELECT).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SELECT</em>&nbsp;</td><td>SELECT must be declared EXTERNAL in the calling subroutine. If SORT = 'S', SELECT is used to select eigenvalues to sort to the top left of the Schur form. If SORT = 'N', SELECT is not referenced. An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected. Note that a selected complex eigenvalue may no longer satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since ordering may change the value of complex eigenvalues (especially if the eigenvalue is ill-conditioned); in this case INFO is set to N+2 (see INFO below).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the N-by-N matrix A. On exit, A has been overwritten by its real Schur form T.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SDIM</em>&nbsp;</td><td><ul>
<li>If SORT = 'N', SDIM = 0.</li>
<li>If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELECT is true. (Complex conjugate pairs for which SELECT is true for either eigenvalue count as 2.)</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WR</em>&nbsp;</td><td>dimension (N) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WI</em>&nbsp;</td><td>dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues in the same order that they appear on the diagonal of the output Schur form T. Complex conjugate pairs of eigenvalues will appear consecutively with the eigenvalue having the positive imaginary part first.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VS</em>&nbsp;</td><td>dimension (LDVS,N)</p>
<ul>
<li>If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur vectors.</li>
<li>If JOBVS = 'N', VS is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDVS</em>&nbsp;</td><td>The leading dimension of the array VS. LDVS &gt;= 1; if JOBVS = 'V', LDVS &gt;= N.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) contains the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= max(1,3*N). For good performance, LWORK must generally be larger.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BWORK</em>&nbsp;</td><td>dimension (N) Not referenced if SORT = 'N'.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = i, and i is &lt;= N: the QR algorithm failed to compute all the eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI contain those eigenvalues which have converged; if JOBVS = 'V', VS contains the matrix which reduces A to its partially converged Schur form. = N+1: the eigenvalues could not be reordered because some eigenvalues were too close to separate (the problem is very ill-conditioned); = N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Schur form no longer satisfy SELECT=.TRUE. This could also be caused by underflow due to scaling. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a655036816493eebaf9202e0cfa782385"></a><!-- doxytag: member="lapack_doc.c::dgels_" ref="a655036816493eebaf9202e0cfa782385" args="(const char TRANS[1], const int *M, const int *N, const int *NRHS, double *A, const int *LDA, double *B, const int *LDB, double *WORK, const int *LWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgels_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>TRANS</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A. </p>
<p>It is assumed that A has full rank.</p>
<p>The following options are provided:</p>
<ul>
<li>1. If TRANS = 'N' and m &gt;= n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A*X ||.</li>
</ul>
<ul>
<li>2. If TRANS = 'N' and m &lt; n: find the minimum norm solution of an underdetermined system A * X = B.</li>
</ul>
<ul>
<li>3. If TRANS = 'T' and m &gt;= n: find the minimum norm solution of an undetermined system A**T * X = B.</li>
</ul>
<ul>
<li>4. If TRANS = 'T' and m &lt; n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A**T * X ||.</li>
</ul>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TRANS</em>&nbsp;</td><td><ul>
<li>= 'N': the linear system involves A;</li>
<li>= 'T': the linear system involves A**T.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NRHS</em>&nbsp;</td><td>The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if M &gt;= N, A is overwritten by details of its QR factorization as returned by DGEQRF;</li>
<li>if M &lt; N, A is overwritten by details of its LQ factorization as returned by DGELQF.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,NRHS) On entry, the matrix B of right hand side vectors, stored columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS</p>
<ul>
<li>if TRANS = 'T'. On exit, if INFO = 0, B is overwritten by the solution vectors, stored columnwise:</li>
<li>if TRANS = 'N' and m &gt;= n, rows 1 to n of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements N+1 to M in that column;</li>
<li>if TRANS = 'N' and m &lt; n, rows 1 to N of B contain the minimum norm solution vectors;</li>
<li>if TRANS = 'T' and m &gt;= n, rows 1 to M of B contain the minimum norm solution vectors;</li>
<li>if TRANS = 'T' and m &lt; n, rows 1 to M of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements M+1 to N in that column.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= MAX(1,M,N).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= max( 1, MN + max( MN, NRHS ) ). For optimal performance, LWORK &gt;= max( 1, MN + max( MN, NRHS )*NB ). where MN = min(M,N) and NB is the optimum block size. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i, the i-th diagonal element of the triangular factor of A is zero, so that A does not have full rank; the least squares solution could not be computed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accd9d170d878a61ef4f5591665f87cc0"></a><!-- doxytag: member="lapack_doc.c::dgelsd_" ref="accd9d170d878a61ef4f5591665f87cc0" args="(const int *M, const int *N, const int *NRHS, double *A, const int *LDA, double *B, const int *LDB, double *S, const double *RCOND, int *RANK, double *WORK, int *LWORK, int *IWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgelsd_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>RCOND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>RANK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DGELSD computes the minimum-norm solution to a real linear least squares problem. </p>
<p>Minimizes <img class="formulaInl" alt="$| b - A*x |$" src="form_51.png"/> using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The problem is solved in three steps:</p>
<ul>
<li>(1) Reduce the coefficient matrix A to bidiagonal form with Householder transformations, reducing the original problem into a "bidiagonal least squares problem" (BLS)</li>
<li>(2) Solve the BLS using a divide and conquer approach.</li>
<li>(3) Apply back all the Householder tranformations to solve the original least squares problem.</li>
</ul>
<p>The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NRHS</em>&nbsp;</td><td>The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A has been destroyed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, B is overwritten by the N-by-NRHS solution matrix X. If m &gt;= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements n+1:m in that column.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S</em>&nbsp;</td><td>dimension (min(M,N)) The singular values of A in decreasing order. The condition number of A in the 2-norm = S(1)/S(min(m,n)).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RCOND</em>&nbsp;</td><td>RCOND is used to determine the effective rank of A. Singular values S(i) &lt;= RCOND*S(1) are treated as zero. If RCOND &lt; 0, machine precision is used instead.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>RANK</em>&nbsp;</td><td>The effective rank of A, i.e., the number of singular values which are greater than RCOND*S(1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK must be at least 1. The exact minimum amount of workspace needed depends on M, N and NRHS. As long as LWORK is at least 12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2, if M is greater than or equal to N or 12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2, if M is less than N, the code will execute correctly. SMLSIZ is returned by ILAENV and is equal to the maximum size of the subproblems at the bottom of the computation tree (usually about 25), and NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 ) For good performance, LWORK should generally be larger. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IWORK</em>&nbsp;</td><td>dimension (MAX(1,LIWORK)) LIWORK &gt;= max(1, 3 * MINMN * NLVL + 11 * MINMN), where MINMN = MIN( M,N ). On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: the algorithm for computing the SVD failed to converge; if INFO = i, i off-diagonal elements of an intermediate bidiagonal form did not converge to zero. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00fb7fb5cfb28095fe4fff98414b9535"></a><!-- doxytag: member="lapack_doc.c::dgesvd_" ref="a00fb7fb5cfb28095fe4fff98414b9535" args="(const char jobu[1], const char jobvt[1], const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *Vt, const int *ldvt, double *work, const int *lwork, int *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgesvd_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>jobu</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>jobvt</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute SVD. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobu</em>&nbsp;</td><td>Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= 'A': all M columns of U are returned in array U:</li>
<li>= 'S': the first min(m,n) columns of U (the left singular vectors) are returned in the array U;</li>
<li>= 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A;</li>
<li>= 'N': no columns of U (no left singular vectors) are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobvt</em>&nbsp;</td><td>Specifies options for computing all or part of the matrix V**T:</p>
<ul>
<li>= 'A': all N rows of V**T are returned in the array VT;</li>
<li>= 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT;</li>
<li>= 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A;</li>
<li>= 'N': no rows of V**T (no right singular vectors) are computed. JOBVT and JOBU cannot both be 'O'.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBU = 'O', A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBVT = 'O', A is overwritten with the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S</em>&nbsp;</td><td>The singular values of A, sorted so that S(i) &gt;= S(i+1). dimension (min(M,N))</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>dimension (LDU,UCOL) (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.</p>
<ul>
<li>If JOBU = 'A', U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBU = 'N' or 'O', U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>The leading dimension of the array U. LDU &gt;= 1; if JOBU = 'S' or 'A', LDU &gt;= M. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Vt</em>&nbsp;</td><td>dimension (LDVT,N)</p>
<ul>
<li>If JOBVT = 'A', VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBVT = 'S', VT contains the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBVT = 'N' or 'O', VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>The leading dimension of the array VT. LDVT &gt;= 1; if JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK; if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged superdiagonal elements of an upper bidiagonal matrix B whose diagonal is in S (not necessarily sorted). B satisfies A = U * B * VT, so it has the same singular values as A, and singular vectors related by U and VT.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)). For good performance, LWORK should generally be larger. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td><ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if DBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of WORK above for details. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e7dbf9e241b4bfaab9c534cba4418fb"></a><!-- doxytag: member="lapack_doc.c::dgetrf_" ref="a7e7dbf9e241b4bfaab9c534cba4418fb" args="(const int *M, const int *N, double *A, const int *LDA, int *IPIV, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgetrf_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IPIV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = P * L * U \]" src="form_50.png"/>
</p>
<p> where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On entry, the M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IPIV</em>&nbsp;</td><td>array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad81e1d79d969b6d3448b52d83426f8ed"></a><!-- doxytag: member="lapack_doc.c::dgetri_" ref="ad81e1d79d969b6d3448b52d83426f8ed" args="(const int *N, double *A, const int *LDA, const int *IPIV, double *WORK, const int *LWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dgetri_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>IPIV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>type for operations </p>
<p>Inverse of matrix using LU factorization by *getrf.</p>
<p>You must call *getrf before you call *getri.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>Order of the matrix A </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>on entry the L and U factors from *getrf, on exit the inverse of the original A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>number of rows in A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPIV</em>&nbsp;</td><td>pivot indices from sgetrf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WORK</em>&nbsp;</td><td>workspace array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>length of work, optimally &gt; n*nb where nb is the optimal blocksize return by ilaenv_ </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td>output. info==0 for success, info&lt;zero for illegal argument, info &gt; 0 for singular matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67e9b8a55c0c3e696be317066d3ce573"></a><!-- doxytag: member="lapack_doc.c::dlacpy_" ref="a67e9b8a55c0c3e696be317066d3ce573" args="(const char UPLO[1], const int *M, const int *N, const double *A, const int *LDA, double *B, const int *LDB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlacpy_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>UPLO</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all or part of a two-dimensional matrix A to another matrix B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>UPLO</em>&nbsp;</td><td>Specifies the part of the matrix A to be copied to B.</p>
<ul>
<li>= 'U': Upper triangular part</li>
<li>= 'L': Lower triangular part</li>
<li>Otherwise: All of the matrix A</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) The m by n matrix A. If UPLO = 'U', only the upper triangle or trapezoid is accessed; if UPLO = 'L', only the lower triangle or trapezoid is accessed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,N) On exit, B = A in the locations specified by UPLO.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= max(1,M). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a971eb1a938d6f3441cacd0439951d477"></a><!-- doxytag: member="lapack_doc.c::dlag2s_" ref="a971eb1a938d6f3441cacd0439951d477" args="(const int *M, const int *N, double *A, const int *LDA, float *SA, const int *LDSA, const int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlag2s_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a DOUBLE PRECISION matrix, SA, to a SINGLE PRECISION matrix, A. </p>
<p>This is a helper routine so there is no argument checking.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of lines of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On entry, the M-by-N coefficient matrix A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SA</em>&nbsp;</td><td>On exit, if INFO=0, the M-by-N coefficient matrix SA.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDSA</em>&nbsp;</td><td>The leading dimension of the array SA. LDSA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&gt; 0: if INFO = k, the (i,j) entry of the matrix A has overflowed when moving from DOUBLE PRECISION to SINGLE k is given by k = (i-1)*LDA+j </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4174555ba70641cea33e3cb92048e84"></a><!-- doxytag: member="lapack_doc.c::dlarnv_" ref="ae4174555ba70641cea33e3cb92048e84" args="(const int *IDIST, int ISEED[4], const int *N, double *X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlarnv_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ISEED</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector of n random real numbers from a uniform or normal distribution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IDIST</em>&nbsp;</td><td>Specifies the distribution of the random numbers:</p>
<ul>
<li>= 1: uniform (0,1)</li>
<li>= 2: uniform (-1,1)</li>
<li>= 3: normal (0,1)</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ISEED</em>&nbsp;</td><td>On entry, the seed of the random number generator; the array elements must be between 0 and 4095, and ISEED(4) must be odd. On exit, the seed is updated.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of random numbers to be generated.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>X</em>&nbsp;</td><td>The generated random numbers.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine calls the auxiliary routine DLARUV to generate random real numbers from a uniform (0,1) distribution, in batches of up to 128 using vectorisable code. The Box-Muller method is used to transform numbers from a uniform to a normal distribution. </p>

</div>
</div>
<a class="anchor" id="afa186c0bc0ceae470beb34001467357d"></a><!-- doxytag: member="lapack_doc.c::dlaruv_" ref="afa186c0bc0ceae470beb34001467357d" args="(int ISEED[4], const int *N, double *X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlaruv_ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ISEED</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector of n random real numbers from a uniform (0,1) distribution (n &lt;= 128). </p>
<p>This is an auxiliary routine called by DLARNV and ZLARNV.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ISEED</em>&nbsp;</td><td>ISEED is INTEGER array, dimension (4) On entry, the seed of the random number generator; the array elements must be between 0 and 4095, and ISEED(4) must be odd. On exit, the seed is updated.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>N is INTEGER The number of random numbers to be generated. N &lt;= 128.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>X</em>&nbsp;</td><td>X is AA_TYPE PRECISION array, dimension (N) The generated random numbers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd.</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>November 2011</dd></dl>
<p>This routine uses a multiplicative congruential method with modulus 2**48 and multiplier 33952834046453 (see G.S.Fishman, 'Multiplicative congruential random number generators with modulus 2**b: an exhaustive analysis for b = 32 and a partial analysis for b = 48', Math. Comp. 189, pp 331-344, 1990).</p>
<p>48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is portable across machines with integers of 32 bits or more. </p>

</div>
</div>
<a class="anchor" id="a60ae7d4abe435240135b72ab9f6255e4"></a><!-- doxytag: member="lapack_doc.c::dlascl_" ref="a60ae7d4abe435240135b72ab9f6255e4" args="(const char TYPE[1], const int *KL, const int *KU, const double *CFROM, const double *CTO, const int *M, const int *N, double *A, const int *LDA, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlascl_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>TYPE</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>CFROM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>CTO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies the M by N real matrix A by the real scalar CTO/CFROM. </p>
<p>k This is done without over/underflow as long as the final result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that A may be full, upper triangular, lower triangular, upper Hessenberg, or banded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TYPE</em>&nbsp;</td><td>TYPE indices the storage type of the input matrix.</p>
<ul>
<li>= 'G': A is a full matrix.</li>
<li>= 'L': A is a lower triangular matrix.</li>
<li>= 'U': A is an upper triangular matrix.</li>
<li>= 'H': A is an upper Hessenberg matrix.</li>
<li>= 'B': A is a symmetric band matrix with lower bandwidth KL and upper bandwidth KU and with the only the lower half stored.</li>
<li>= 'Q': A is a symmetric band matrix with lower bandwidth KL and upper bandwidth KU and with the only the upper half stored.</li>
<li>= 'Z': A is a band matrix with lower bandwidth KL and upper bandwidth KU.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>KL</em>&nbsp;</td><td>The lower bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>KU</em>&nbsp;</td><td>The upper bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>CFROM</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>CTO</em>&nbsp;</td><td>The matrix A is multiplied by CTO/CFROM. A(I,J) is computed without over/underflow if the final result CTO*A(I,J)/CFROM can be represented without over/underflow. CFROM must be nonzero.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>The matrix to be multiplied by CTO/CFROM. See TYPE for the storage type.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td>(output) INTEGER</p>
<ul>
<li>0 - successful exit</li>
<li>&lt;0 - if INFO = -i, the i-th argument had an illegal value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a229bde086d03f7a2cdd23d9701e12e38"></a><!-- doxytag: member="lapack_doc.c::dlaset_" ref="a229bde086d03f7a2cdd23d9701e12e38" args="(const char UPLO[1], const int *M, const int *N, const double *ALPHA, const double *BETA, double *A, const int *LDA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void dlaset_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>UPLO</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initializes an m-by-n matrix A to BETA on the diagonal and ALPHA on the offdiagonals. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>UPLO</em>&nbsp;</td><td>UPLO is CHARACTER*1. Specifies the part of the matrix A to be set.</p>
<ul>
<li>= 'U': Upper triangular part is set; the strictly lower triangular part of A is not changed.</li>
<li>= 'L': Lower triangular part is set; the strictly upper triangular part of A is not changed.</li>
<li>Otherwise: All of the matrix A is set.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>M is INTEGER. The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>N is INTEGER. The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ALPHA</em>&nbsp;</td><td>ALPHA is DOUBLE PRECISION. The constant to which the offdiagonal elements are to be set.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>BETA</em>&nbsp;</td><td>BETA is DOUBLE PRECISION. The constant to which the diagonal elements are to be set.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>A is DOUBLE PRECISION array, dimension (LDA,N). On exit, the leading m-by-n submatrix of A is set as follows:</p>
<ul>
<li>if UPLO = 'U', A(i,j) = ALPHA, 1&lt;=i&lt;=j-1, 1&lt;=j&lt;=n,</li>
<li>if UPLO = 'L', A(i,j) = ALPHA, j+1&lt;=i&lt;=m, 1&lt;=j&lt;=n,</li>
<li>otherwise, A(i,j) = ALPHA, 1&lt;=i&lt;=m, 1&lt;=j&lt;=n, i.ne.j, and, for all UPLO, A(i,i) = BETA, 1&lt;=i&lt;=min(m,n).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>LDA is INTEGER. The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd.</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>November 2011 </dd></dl>

</div>
</div>
<a class="anchor" id="a049f2c28303ee20ec58495b75003a61a"></a><!-- doxytag: member="lapack_doc.c::ilaenv_" ref="a049f2c28303ee20ec58495b75003a61a" args="(const int *ispec, const char *name, const char *opts, const int *n1, const int *n2, const int *n3, const int *n4, int name_length, int opts_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API int ilaenv_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>ispec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opts_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ILAENV is called from the LAPACK routines to choose problem-dependent parameters for the local environment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ispec</em>&nbsp;</td><td>Specifies the parameter to be returned as the value of ILAENV.</p>
<ul>
<li>= 1: the optimal blocksize; if this value is 1, an unblocked algorithm will give the best performance.</li>
<li>= 2: the minimum block size for which the block routine should be used; if the usable block size is less than this value, an unblocked routine should be used.</li>
<li>= 3: the crossover point (in a block routine, for N less than this value, an unblocked routine should be used)</li>
<li>= 4: the number of shifts, used in the nonsymmetric eigenvalue routines (DEPRECATED)</li>
<li>= 5: the minimum column dimension for blocking to be used; rectangular blocks must have dimension at least k by m, where k is given by ILAENV(2,...) and m by ILAENV(5,...)</li>
<li>= 6: the crossover point for the SVD (when reducing an m by n matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds this value, a QR factorization is used first to reduce the matrix to a triangular form.)</li>
<li>= 7: the number of processors</li>
<li>= 8: the crossover point for the multishift QR method for nonsymmetric eigenvalue problems (DEPRECATED)</li>
<li>= 9: maximum size of the subproblems at the bottom of the computation tree in the divide-and-conquer algorithm (used by xGELSD and xGESDD)</li>
<li>=10: ieee NaN arithmetic can be trusted not to trap</li>
<li>=11: infinity arithmetic can be trusted not to trap</li>
<li>12 &lt;= ISPEC &lt;= 16: xHSEQR or one of its subroutines, see IPARMQ for detailed explanation</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the calling subroutine, in either upper case or lower case.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The character options to the subroutine NAME, concatenated into a single character string. For example, UPLO = 'U', TRANS = 'T', and DIAG = 'N' for a triangular routine would be specified as OPTS = 'UTN'.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n1</em>&nbsp;</td><td>(input) INTEGER </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n2</em>&nbsp;</td><td>(input) INTEGER </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n3</em>&nbsp;</td><td>(input) INTEGER </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n4</em>&nbsp;</td><td>(input) INTEGER Problem dimensions for the subroutine NAME; these may not all be required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_length</em>&nbsp;</td><td>fortran string brain damage, length of name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts_length</em>&nbsp;</td><td>fortran string brain damage, length of opts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4136300dce44d53bf39d86bfe123cf38"></a><!-- doxytag: member="lapack_doc.c::sgebal_" ref="a4136300dce44d53bf39d86bfe123cf38" args="(const char JOB[1], int *N, float *A, const int *LDA, int *ILO, int *IHI, float *SCALE, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgebal_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>JOB</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>SCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Balances a general real matrix A. </p>
<p>This involves, first, permuting A by a similarity transformation to isolate eigenvalues in the first 1 to ILO-1 and last IHI+1 to N elements on the diagonal; and second, applying a diagonal similarity transformation to rows and columns ILO to IHI to make the rows and columns as close in norm as possible. Both steps are optional.</p>
<p>Balancing may reduce the 1-norm of the matrix, and improve the accuracy of the computed eigenvalues and/or eigenvectors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>JOB</em>&nbsp;</td><td>Specifies the operations to be performed on A:</p>
<ul>
<li>= 'N': none: simply set ILO = 1, IHI = N, SCALE(I) = 1.0 for i = 1,...,N;</li>
<li>= 'P': permute only;</li>
<li>= 'S': scale only;</li>
<li>= 'B': both permute and scale.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the input matrix A. On exit, A is overwritten by the balanced matrix. If JOB = 'N', A is not referenced. See Further Details.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ILO</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IHI</em>&nbsp;</td><td>ILO and IHI are set to integers such that on exit A(i,j) = 0 if i &gt; j and j = 1,...,ILO-1 or I = IHI+1,...,N. If JOB = 'N' or 'S', ILO = 1 and IHI = N.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SCALE</em>&nbsp;</td><td>dimension (N) Details of the permutations and scaling factors applied to A. If P(j) is the index of the row and column interchanged with row and column j and D(j) is the scaling factor applied to row and column j, then SCALE(j) = P(j) for j = 1,...,ILO-1 = D(j) for j = ILO,...,IHI = P(j) for j = IHI+1,...,N. The order in which the interchanges are made is N to IHI+1, then 1 to ILO-1.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26f3ec0151ace5d61b70bfe87f6017ad"></a><!-- doxytag: member="lapack_doc.c::sgees_" ref="a26f3ec0151ace5d61b70bfe87f6017ad" args="(const char JOBVS[1], const char SORT[1], int(*SELECT)(const float *, const float *), const int *N, float *A, const int *LDA, int *SDIM, float *WR, float *WI, float *VS, const int *LDVS, float *WORK, const int *LWORK, int *BWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgees_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>JOBVS</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>SORT</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const float *, const float *)&nbsp;</td>
          <td class="paramname"> <em>SELECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>SDIM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDVS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes for an N-by-N real nonsymmetric matrix A, the eigenvalues, the real Schur form T, and, optionally, the matrix of Schur vectors Z. </p>
<p>This gives the Schur factorization A = Z*T*(Z**T).</p>
<p>Optionally, it also orders the eigenvalues on the diagonal of the real Schur form so that selected eigenvalues are at the top left. The leading columns of Z then form an orthonormal basis for the invariant subspace corresponding to the selected eigenvalues.</p>
<p>A matrix is in real Schur form if it is upper quasi-triangular with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the form [ a b ] [ c a ]</p>
<p>where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>JOBVS</em>&nbsp;</td><td><ul>
<li>= 'N': Schur vectors are not computed;</li>
<li>= 'V': Schur vectors are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SORT</em>&nbsp;</td><td>Specifies whether or not to order the eigenvalues on the diagonal of the Schur form.</p>
<ul>
<li>= 'N': Eigenvalues are not ordered;</li>
<li>= 'S': Eigenvalues are ordered (see SELECT).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SELECT</em>&nbsp;</td><td>SELECT must be declared EXTERNAL in the calling subroutine. If SORT = 'S', SELECT is used to select eigenvalues to sort to the top left of the Schur form. If SORT = 'N', SELECT is not referenced. An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex conjugate pair of eigenvalues is selected, then both complex eigenvalues are selected. Note that a selected complex eigenvalue may no longer satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since ordering may change the value of complex eigenvalues (especially if the eigenvalue is ill-conditioned); in this case INFO is set to N+2 (see INFO below).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The order of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the N-by-N matrix A. On exit, A has been overwritten by its real Schur form T.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>SDIM</em>&nbsp;</td><td><ul>
<li>If SORT = 'N', SDIM = 0.</li>
<li>If SORT = 'S', SDIM = number of eigenvalues (after sorting) for which SELECT is true. (Complex conjugate pairs for which SELECT is true for either eigenvalue count as 2.)</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WR</em>&nbsp;</td><td>dimension (N) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WI</em>&nbsp;</td><td>dimension (N) WR and WI contain the real and imaginary parts, respectively, of the computed eigenvalues in the same order that they appear on the diagonal of the output Schur form T. Complex conjugate pairs of eigenvalues will appear consecutively with the eigenvalue having the positive imaginary part first.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>VS</em>&nbsp;</td><td>dimension (LDVS,N)</p>
<ul>
<li>If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur vectors.</li>
<li>If JOBVS = 'N', VS is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDVS</em>&nbsp;</td><td>The leading dimension of the array VS. LDVS &gt;= 1; if JOBVS = 'V', LDVS &gt;= N.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) contains the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= max(1,3*N). For good performance, LWORK must generally be larger.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BWORK</em>&nbsp;</td><td>dimension (N) Not referenced if SORT = 'N'.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if INFO = i, and i is &lt;= N: the QR algorithm failed to compute all the eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI contain those eigenvalues which have converged; if JOBVS = 'V', VS contains the matrix which reduces A to its partially converged Schur form. = N+1: the eigenvalues could not be reordered because some eigenvalues were too close to separate (the problem is very ill-conditioned); = N+2: after reordering, roundoff changed values of some complex eigenvalues so that leading eigenvalues in the Schur form no longer satisfy SELECT=.TRUE. This could also be caused by underflow due to scaling. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24f702b20a2c65d0b7b1b95bda7fb984"></a><!-- doxytag: member="lapack_doc.c::sgels_" ref="a24f702b20a2c65d0b7b1b95bda7fb984" args="(const char TRANS[1], const int *M, const int *N, const int *NRHS, float *A, const int *LDA, float *B, const int *LDB, float *WORK, const int *LWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgels_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>TRANS</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves overdetermined or underdetermined real linear systems involving an M-by-N matrix A, or its transpose, using a QR or LQ factorization of A. </p>
<p>It is assumed that A has full rank.</p>
<p>The following options are provided:</p>
<ul>
<li>1. If TRANS = 'N' and m &gt;= n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A*X ||.</li>
</ul>
<ul>
<li>2. If TRANS = 'N' and m &lt; n: find the minimum norm solution of an underdetermined system A * X = B.</li>
</ul>
<ul>
<li>3. If TRANS = 'T' and m &gt;= n: find the minimum norm solution of an undetermined system A**T * X = B.</li>
</ul>
<ul>
<li>4. If TRANS = 'T' and m &lt; n: find the least squares solution of an overdetermined system, i.e., solve the least squares problem minimize || B - A**T * X ||.</li>
</ul>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TRANS</em>&nbsp;</td><td><ul>
<li>= 'N': the linear system involves A;</li>
<li>= 'T': the linear system involves A**T.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NRHS</em>&nbsp;</td><td>The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;=0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if M &gt;= N, A is overwritten by details of its QR factorization as returned by DGEQRF;</li>
<li>if M &lt; N, A is overwritten by details of its LQ factorization as returned by DGELQF.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,NRHS) On entry, the matrix B of right hand side vectors, stored columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS</p>
<ul>
<li>if TRANS = 'T'. On exit, if INFO = 0, B is overwritten by the solution vectors, stored columnwise:</li>
<li>if TRANS = 'N' and m &gt;= n, rows 1 to n of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements N+1 to M in that column;</li>
<li>if TRANS = 'N' and m &lt; n, rows 1 to N of B contain the minimum norm solution vectors;</li>
<li>if TRANS = 'T' and m &gt;= n, rows 1 to M of B contain the minimum norm solution vectors;</li>
<li>if TRANS = 'T' and m &lt; n, rows 1 to M of B contain the least squares solution vectors; the residual sum of squares for the solution in each column is given by the sum of squares of elements M+1 to N in that column.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= MAX(1,M,N).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= max( 1, MN + max( MN, NRHS ) ). For optimal performance, LWORK &gt;= max( 1, MN + max( MN, NRHS )*NB ). where MN = min(M,N) and NB is the optimum block size. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i, the i-th diagonal element of the triangular factor of A is zero, so that A does not have full rank; the least squares solution could not be computed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf87acce17938a93459011156ad0b17f"></a><!-- doxytag: member="lapack_doc.c::sgelsd_" ref="adf87acce17938a93459011156ad0b17f" args="(const int *M, const int *N, const int *NRHS, float *A, const int *LDA, float *B, const int *LDB, float *S, const float *RCOND, int *RANK, float *WORK, int *LWORK, int *IWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgelsd_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>RCOND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>RANK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DGELSD computes the minimum-norm solution to a real linear least squares problem. </p>
<p>Minimizes <img class="formulaInl" alt="$| b - A*x |$" src="form_51.png"/> using the singular value decomposition (SVD) of A. A is an M-by-N matrix which may be rank-deficient.</p>
<p>Several right hand side vectors b and solution vectors x can be handled in a single call; they are stored as the columns of the M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix X.</p>
<p>The problem is solved in three steps:</p>
<ul>
<li>(1) Reduce the coefficient matrix A to bidiagonal form with Householder transformations, reducing the original problem into a "bidiagonal least squares problem" (BLS)</li>
<li>(2) Solve the BLS using a divide and conquer approach.</li>
<li>(3) Apply back all the Householder tranformations to solve the original least squares problem.</li>
</ul>
<p>The effective rank of A is determined by treating as zero those singular values which are less than RCOND times the largest singular value.</p>
<p>The divide and conquer algorithm makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NRHS</em>&nbsp;</td><td>The number of right hand sides, i.e., the number of columns of the matrices B and X. NRHS &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) On entry, the M-by-N matrix A. On exit, A has been destroyed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,NRHS) On entry, the M-by-NRHS right hand side matrix B. On exit, B is overwritten by the N-by-NRHS solution matrix X. If m &gt;= n and RANK = n, the residual sum-of-squares for the solution in the i-th column is given by the sum of squares of elements n+1:m in that column.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S</em>&nbsp;</td><td>dimension (min(M,N)) The singular values of A in decreasing order. The condition number of A in the 2-norm = S(1)/S(min(m,n)).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>RCOND</em>&nbsp;</td><td>RCOND is used to determine the effective rank of A. Singular values S(i) &lt;= RCOND*S(1) are treated as zero. If RCOND &lt; 0, machine precision is used instead.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>RANK</em>&nbsp;</td><td>The effective rank of A, i.e., the number of singular values which are greater than RCOND*S(1).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>WORK</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>The dimension of the array WORK. LWORK must be at least 1. The exact minimum amount of workspace needed depends on M, N and NRHS. As long as LWORK is at least 12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2, if M is greater than or equal to N or 12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2, if M is less than N, the code will execute correctly. SMLSIZ is returned by ILAENV and is equal to the maximum size of the subproblems at the bottom of the computation tree (usually about 25), and NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 ) For good performance, LWORK should generally be larger. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IWORK</em>&nbsp;</td><td>dimension (MAX(1,LIWORK)) LIWORK &gt;= max(1, 3 * MINMN * NLVL + 11 * MINMN), where MINMN = MIN( M,N ). On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: the algorithm for computing the SVD failed to converge; if INFO = i, i off-diagonal elements of an intermediate bidiagonal form did not converge to zero. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4005be2875da71d06ac3523dd2d2ab9d"></a><!-- doxytag: member="lapack_doc.c::sgesvd_" ref="a4005be2875da71d06ac3523dd2d2ab9d" args="(const char jobu[1], const char jobvt[1], const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *Vt, const int *ldvt, float *work, const int *lwork, int *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgesvd_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>jobu</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>jobvt</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>Vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>ldvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute SVD. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobu</em>&nbsp;</td><td>Specifies options for computing all or part of the matrix U:</p>
<ul>
<li>= 'A': all M columns of U are returned in array U:</li>
<li>= 'S': the first min(m,n) columns of U (the left singular vectors) are returned in the array U;</li>
<li>= 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on the array A;</li>
<li>= 'N': no columns of U (no left singular vectors) are computed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jobvt</em>&nbsp;</td><td>Specifies options for computing all or part of the matrix V**T:</p>
<ul>
<li>= 'A': all N rows of V**T are returned in the array VT;</li>
<li>= 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the array VT;</li>
<li>= 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A;</li>
<li>= 'N': no rows of V**T (no right singular vectors) are computed. JOBVT and JOBU cannot both be 'O'.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The number of rows of the input matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number of columns of the input matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On entry, the M-by-N matrix A. On exit,</p>
<ul>
<li>if JOBU = 'O', A is overwritten with the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBVT = 'O', A is overwritten with the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A are destroyed.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lda</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S</em>&nbsp;</td><td>The singular values of A, sorted so that S(i) &gt;= S(i+1). dimension (min(M,N))</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>U</em>&nbsp;</td><td>dimension (LDU,UCOL) (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.</p>
<ul>
<li>If JOBU = 'A', U contains the M-by-M orthogonal matrix U;</li>
<li>if JOBU = 'S', U contains the first min(m,n) columns of U (the left singular vectors, stored columnwise);</li>
<li>if JOBU = 'N' or 'O', U is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldu</em>&nbsp;</td><td>The leading dimension of the array U. LDU &gt;= 1; if JOBU = 'S' or 'A', LDU &gt;= M. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Vt</em>&nbsp;</td><td>dimension (LDVT,N)</p>
<ul>
<li>If JOBVT = 'A', VT contains the N-by-N orthogonal matrix V**T;</li>
<li>if JOBVT = 'S', VT contains the first min(m,n) rows of V**T (the right singular vectors, stored rowwise);</li>
<li>if JOBVT = 'N' or 'O', VT is not referenced.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ldvt</em>&nbsp;</td><td>The leading dimension of the array VT. LDVT &gt;= 1; if JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>work</em>&nbsp;</td><td>dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK(1) returns the optimal LWORK; if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged superdiagonal elements of an upper bidiagonal matrix B whose diagonal is in S (not necessarily sorted). B satisfies A = U * B * VT, so it has the same singular values as A, and singular vectors related by U and VT.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lwork</em>&nbsp;</td><td>The dimension of the array WORK. LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)). For good performance, LWORK should generally be larger. If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td><ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: if DBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of WORK above for details. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60936fca8832219b2caa0d66593e31e0"></a><!-- doxytag: member="lapack_doc.c::sgetrf_" ref="a60936fca8832219b2caa0d66593e31e0" args="(const int *M, const int *N, float *A, const int *LDA, int *IPIV, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgetrf_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IPIV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = P * L * U \]" src="form_50.png"/>
</p>
<p> where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On entry, the M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>IPIV</em>&nbsp;</td><td>array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a241a9b27a306dc51b21fbf08cf59b3c1"></a><!-- doxytag: member="lapack_doc.c::sgetri_" ref="a241a9b27a306dc51b21fbf08cf59b3c1" args="(const int *N, float *A, const int *LDA, const int *IPIV, float *WORK, const int *LWORK, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void sgetri_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>IPIV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>type for operations </p>
<p>Inverse of matrix using LU factorization by *getrf.</p>
<p>You must call *getrf before you call *getri.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>Order of the matrix A </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>on entry the L and U factors from *getrf, on exit the inverse of the original A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>number of rows in A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IPIV</em>&nbsp;</td><td>pivot indices from sgetrf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WORK</em>&nbsp;</td><td>workspace array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LWORK</em>&nbsp;</td><td>length of work, optimally &gt; n*nb where nb is the optimal blocksize return by ilaenv_ </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td>output. info==0 for success, info&lt;zero for illegal argument, info &gt; 0 for singular matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc10696c60ae03d1f4c083aad8235085"></a><!-- doxytag: member="lapack_doc.c::slacpy_" ref="acc10696c60ae03d1f4c083aad8235085" args="(const char UPLO[1], const int *M, const int *N, const float *A, const int *LDA, float *B, const int *LDB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slacpy_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>UPLO</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all or part of a two-dimensional matrix A to another matrix B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>UPLO</em>&nbsp;</td><td>Specifies the part of the matrix A to be copied to B.</p>
<ul>
<li>= 'U': Upper triangular part</li>
<li>= 'L': Lower triangular part</li>
<li>Otherwise: All of the matrix A</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>dimension (LDA,N) The m by n matrix A. If UPLO = 'U', only the upper triangle or trapezoid is accessed; if UPLO = 'L', only the lower triangle or trapezoid is accessed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>B</em>&nbsp;</td><td>dimension (LDB,N) On exit, B = A in the locations specified by UPLO.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDB</em>&nbsp;</td><td>The leading dimension of the array B. LDB &gt;= max(1,M). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab44a6964fe2f0b269fb113fed2208931"></a><!-- doxytag: member="lapack_doc.c::slag2d_" ref="ab44a6964fe2f0b269fb113fed2208931" args="(const int *M, const int *N, float *SA, const int *LDSA, double *A, const int *LDA, const int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slag2d_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a SINGLE PRECISION matrix, SA, to a DOUBLE PRECISION matrix, A. </p>
<p>RMAX is the overflow for the SINGLE PRECISION arithmetic DLAG2S checks that all the entries of A are between -RMAX and RMAX. If not the convertion is aborted and a flag is raised.</p>
<p>This is a helper routine so there is no argument checking.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of lines of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>On exit, if INFO=0, the M-by-N coefficient matrix A.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>SA</em>&nbsp;</td><td>On entry, the M-by-N coefficient matrix SA.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDSA</em>&nbsp;</td><td>The leading dimension of the array SA. LDSA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td><ul>
<li>= 0: successful exit</li>
<li>&gt; 0: if INFO = k, the (i,j) entry of the matrix A has overflowed when moving from DOUBLE PRECISION to SINGLE k is given by k = (i-1)*LDA+j </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25b2a8d91520fea3b9e5f081441f422b"></a><!-- doxytag: member="lapack_doc.c::slarnv_" ref="a25b2a8d91520fea3b9e5f081441f422b" args="(const int *IDIST, int ISEED[4], const int *N, float *X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slarnv_ </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>IDIST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ISEED</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector of n random real numbers from a uniform or normal distribution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IDIST</em>&nbsp;</td><td>Specifies the distribution of the random numbers:</p>
<ul>
<li>= 1: uniform (0,1)</li>
<li>= 2: uniform (-1,1)</li>
<li>= 3: normal (0,1)</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ISEED</em>&nbsp;</td><td>On entry, the seed of the random number generator; the array elements must be between 0 and 4095, and ISEED(4) must be odd. On exit, the seed is updated.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of random numbers to be generated.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>X</em>&nbsp;</td><td>The generated random numbers.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine calls the auxiliary routine DLARUV to generate random real numbers from a uniform (0,1) distribution, in batches of up to 128 using vectorisable code. The Box-Muller method is used to transform numbers from a uniform to a normal distribution. </p>

</div>
</div>
<a class="anchor" id="a96a60f4f8ac54fb62bec4fc2c90a5795"></a><!-- doxytag: member="lapack_doc.c::slaruv_" ref="a96a60f4f8ac54fb62bec4fc2c90a5795" args="(int ISEED[4], const int *N, float *X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slaruv_ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ISEED</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector of n random real numbers from a uniform (0,1) distribution (n &lt;= 128). </p>
<p>This is an auxiliary routine called by DLARNV and ZLARNV.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ISEED</em>&nbsp;</td><td>ISEED is INTEGER array, dimension (4) On entry, the seed of the random number generator; the array elements must be between 0 and 4095, and ISEED(4) must be odd. On exit, the seed is updated.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>N is INTEGER The number of random numbers to be generated. N &lt;= 128.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>X</em>&nbsp;</td><td>X is AA_TYPE PRECISION array, dimension (N) The generated random numbers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd.</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>November 2011</dd></dl>
<p>This routine uses a multiplicative congruential method with modulus 2**48 and multiplier 33952834046453 (see G.S.Fishman, 'Multiplicative congruential random number generators with modulus 2**b: an exhaustive analysis for b = 32 and a partial analysis for b = 48', Math. Comp. 189, pp 331-344, 1990).</p>
<p>48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is portable across machines with integers of 32 bits or more. </p>

</div>
</div>
<a class="anchor" id="a49394e995df80d92c0429d530553df56"></a><!-- doxytag: member="lapack_doc.c::slascl_" ref="a49394e995df80d92c0429d530553df56" args="(const char TYPE[1], const int *KL, const int *KU, const float *CFROM, const float *CTO, const int *M, const int *N, float *A, const int *LDA, int *INFO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slascl_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>TYPE</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>KL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>KU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>CFROM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>CTO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>INFO</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies the M by N real matrix A by the real scalar CTO/CFROM. </p>
<p>k This is done without over/underflow as long as the final result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that A may be full, upper triangular, lower triangular, upper Hessenberg, or banded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TYPE</em>&nbsp;</td><td>TYPE indices the storage type of the input matrix.</p>
<ul>
<li>= 'G': A is a full matrix.</li>
<li>= 'L': A is a lower triangular matrix.</li>
<li>= 'U': A is an upper triangular matrix.</li>
<li>= 'H': A is an upper Hessenberg matrix.</li>
<li>= 'B': A is a symmetric band matrix with lower bandwidth KL and upper bandwidth KU and with the only the lower half stored.</li>
<li>= 'Q': A is a symmetric band matrix with lower bandwidth KL and upper bandwidth KU and with the only the upper half stored.</li>
<li>= 'Z': A is a band matrix with lower bandwidth KL and upper bandwidth KU.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>KL</em>&nbsp;</td><td>The lower bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>KU</em>&nbsp;</td><td>The upper bandwidth of A. Referenced only if TYPE = 'B', 'Q' or 'Z'.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>CFROM</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>CTO</em>&nbsp;</td><td>The matrix A is multiplied by CTO/CFROM. A(I,J) is computed without over/underflow if the final result CTO*A(I,J)/CFROM can be represented without over/underflow. CFROM must be nonzero.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>The matrix to be multiplied by CTO/CFROM. See TYPE for the storage type.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>INFO</em>&nbsp;</td><td>(output) INTEGER</p>
<ul>
<li>0 - successful exit</li>
<li>&lt;0 - if INFO = -i, the i-th argument had an illegal value. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d44fc39f4579d8dea5f4b8fb334f485"></a><!-- doxytag: member="lapack_doc.c::slaset_" ref="a1d44fc39f4579d8dea5f4b8fb334f485" args="(const char UPLO[1], const int *M, const int *N, const float *ALPHA, const float *BETA, float *A, const int *LDA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AA_API void slaset_ </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>UPLO</em>[1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>LDA</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initializes an m-by-n matrix A to BETA on the diagonal and ALPHA on the offdiagonals. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>UPLO</em>&nbsp;</td><td>UPLO is CHARACTER*1. Specifies the part of the matrix A to be set.</p>
<ul>
<li>= 'U': Upper triangular part is set; the strictly lower triangular part of A is not changed.</li>
<li>= 'L': Lower triangular part is set; the strictly upper triangular part of A is not changed.</li>
<li>Otherwise: All of the matrix A is set.</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>M is INTEGER. The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N</em>&nbsp;</td><td>N is INTEGER. The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ALPHA</em>&nbsp;</td><td>ALPHA is DOUBLE PRECISION. The constant to which the offdiagonal elements are to be set.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>BETA</em>&nbsp;</td><td>BETA is DOUBLE PRECISION. The constant to which the diagonal elements are to be set.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>A is DOUBLE PRECISION array, dimension (LDA,N). On exit, the leading m-by-n submatrix of A is set as follows:</p>
<ul>
<li>if UPLO = 'U', A(i,j) = ALPHA, 1&lt;=i&lt;=j-1, 1&lt;=j&lt;=n,</li>
<li>if UPLO = 'L', A(i,j) = ALPHA, j+1&lt;=i&lt;=m, 1&lt;=j&lt;=n,</li>
<li>otherwise, A(i,j) = ALPHA, 1&lt;=i&lt;=m, 1&lt;=j&lt;=n, i.ne.j, and, for all UPLO, A(i,i) = BETA, 1&lt;=i&lt;=min(m,n).</li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LDA</em>&nbsp;</td><td>LDA is INTEGER. The leading dimension of the array A. LDA &gt;= max(1,M).</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd.</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>November 2011 </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Sep 17 2012 22:09:52 for amino by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
